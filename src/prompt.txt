Purpose:
The goal is to build a small, self-contained dependency injection (DI) library in TypeScript.
The library provides a staged builder API for defining factories, validating their dependencies, and sealing them into a container.
The container can resolve tokens into values, handle direct cyclic dependencies via lazy resolution, support multi-binding (multiple factories per token), and allow ad-hoc factory execution via bind.
The output must be a single TypeScript file that includes types, implementation, and Vitest tests, runnable in strict mode with no external dependencies.

You are to output exactly ONE TypeScript module in ONE code block.
Do not add any commentary before or after the code block.

This single file must contain, in order:

1. Type definitions
2. Implementation
3. Vitest tests

I will copy and paste this file into my project and run Vitest. The implementation must not rely on Node.js APIs (isomorphic / pure JavaScript). Only the tests may import Vitest functions and types.

Environment and constraints:

* Target: isomorphic (pure JavaScript / TypeScript); no Node-only APIs in implementation.
* TypeScript: strict mode true.
* Module system: ESM compatible.
* No external runtime dependencies. Tests may import vitest functions (test, expect, etc).
* Tests should be a flat list using the "test" function ( no suites ).
* Tests should be self-contained ( no global helpers ) and test little things ( simple context ).
* The file must be self-contained: do not import from other project files.
* The implementation must be deterministic and side-effect free except for constructing values on resolve.

Core concepts to implement:

Token

* Type is string.
* Used as unique keys for registrations.
* Always display tokens in errors.

Factory

* Factories are the only way to produce values (no classes, constructors, or decorators).
<><><><><>
* Factories acquire dependencies lazily by calling resolve(token).

Resolver

* Type: \<T = unknown>(token: Token) => T | Promise<T>
* Provided to factories and to bind.
* Must support cycles by returning a stable placeholder during in-flight construction.

Metadata (from defineLazy\*)

* Each define call records: token, factory, optional deps, optional lazy flag.
* lazy true means assign does not enforce that deps are already assigned. Execution still occurs only on first resolve.

Bindings and multi-binding

* A token can have one or many factories assigned.
* Assignment order is preserved. Resolving a multi-bound token returns values in the same order.
* Each assigned factory executes at most once per container instance (memoized).

Direct cyclic dependencies

* Allowed (A <-> B and longer rings).
* During construction, if resolve encounters a token already constructing, it must return a placeholder that resolves to the final value once ready.
* Access before initialization must either forward once ready or throw error: "Cyclic access before initialization: <token> (path: A > B > A)".
* Must avoid deadlocks for synchronous cycles.

Staged builder API:

Stage 1 methods

* defineLazy(token, factory, options?) -> Stage2
  Adds one metadata entry (no validation). Throws if token invalid, factory invalid, or deps has duplicates. Returns new Stage2.
* defineLazyMany(entries) -> Stage2
  Adds many metadata entries atomically. Fails if any entry invalid.

Stage 2 methods

* defineLazy and defineLazyMany as in Stage 1.
* assign(token) -> Stage3
  Promotes the oldest unassigned metadata entry for that token into the assigned registry.
  Validation: if deps are present, each dep must already be assigned unless the entry has lazy true.
  If validation fails, throw error "Missing assigned dependency <dep> for <token> (require assign order: deps first)".
  If no metadata pending, throw error "No pending metadata for token: <token>".
  Returns new Stage3.
* assignMany(list) -> Stage3
  Batch promote multiple entries. Input can be list of tokens or list of {token, count}.
  All-or-nothing: if one fails, none are promoted.

Stage 3 methods

* assign and assignMany as in Stage 2.
* seal() -> Container
  Freezes assignments and returns a container object.

Container API:

* resolve(token) -> value | value\[] | Promise<value> | Promise\<value\[]>
  If one factory assigned, return single value.
  If many factories, return array in assignment order.
  First call executes factory and caches result; subsequent calls reuse cached value.
  If factory throws, rethrow with error message including resolution path.
  If token has no assignment, throw "Unregistered token: <token>".
  Must handle async factories (return Promise).
  Must detect cycles and show path like "A > B > C".

* bind(factory) -> () => any | Promise<any>
  Accepts a tokenless factory and returns an argument-less function.
  That function executes the factory with the container’s resolver.
  Useful for ad-hoc computations requiring DI without registration.

Validation and error handling:

* defineLazy only records metadata.
* assign enforces dependency presence unless lazy true.
* seal always succeeds.
* resolve enforces runtime rules (missing token, factory errors, cycles).
* Always include resolution path in error messages with " > " as separator.
* defineLazyMany and assignMany are atomic (all or none).
* Duplicate deps in metadata are rejected.

Determinism and performance:

* Lookup by token must be O(1) using Map\<Token, Binding\[]>.
* Each factory is memoized per container instance.
* Implementation must be isomorphic.

Vitest tests to include:

1. Simple factory registration and resolution.
2. Lazy evaluation: factory not executed until first resolve.
3. Direct cyclic dependency resolution with placeholders.
4. assign fails if dependency is missing.
5. assignMany works and resolves multiple factories.
6. bind executes a tokenless factory with injected dependencies.

---

Do you want me to also add an explicit “Success criteria” section at the end (like: “all tests must pass, print no extra logs, no console output unless errors”)? That sometimes helps when running Vitest.
